class Mutex {
  constructor() {
    this._queue = [];
    this._locked = false;
  }

  lock() {
    return new Promise(resolve => {
      if (!this._locked) {
        this._locked = true;
        resolve(this._unlock.bind(this));
      } else {
        this._queue.push(resolve);
      }
    });
  }

  _unlock() {
    if (this._queue.length > 0) {
      const next = this._queue.shift();
      next(this._unlock.bind(this));
    } else {
      this._locked = false;
    }
  }

  async run(fn) {
    const unlock = await this.lock();
    try {
      return await fn();
    } finally {
      unlock();
    }
  }
}




const fs = require("fs").promises;

class SimpleDB {
  constructor(filename) {
    this.filename = filename;
    this.walFile = filename + ".wal";
    this.index = {};
    this.mutex = new Mutex();
  }

  async init() {
    await fs.open(this.filename, "a+");
    await fs.open(this.walFile, "a+");
    await this._recoverFromWal();
    await this._loadIndex();
  }

  async _recoverFromWal() {
    try {
      const walData = await fs.readFile(this.walFile);
      if (walData.length) {
        await fs.appendFile(this.filename, walData);
        await fs.truncate(this.walFile, 0);
      }
    } catch {}
  }

  async _loadIndex() {
    this.index = {};
    let pos = 0;
    const data = await fs.readFile(this.filename);
    while (pos < data.length) {
      const keyLen = data.readUInt32LE(pos);
      const valLen = data.readUInt32LE(pos + 4);
      const key = data.subarray(pos + 8, pos + 8 + keyLen).toString();
      this.index[key] = { pos, len: 8 + keyLen + valLen };
      pos += 8 + keyLen + valLen;
    }
  }

  async put(key, value) {
    return this.mutex.run(async () => {
      const valStr = JSON.stringify({ v: value, deleted: false });
      const keyBuf = Buffer.from(key);
      const valBuf = Buffer.from(valStr);

      const header = Buffer.alloc(8);
      header.writeUInt32LE(keyBuf.length, 0);
      header.writeUInt32LE(valBuf.length, 4);

      const record = Buffer.concat([header, keyBuf, valBuf]);

      await fs.appendFile(this.walFile, record);
      await fs.appendFile(this.filename, record);
      await fs.truncate(this.walFile, 0);

      const pos = (await fs.stat(this.filename)).size - record.length;
      this.index[key] = { pos, len: record.length };
    });
  }

  async get(key) {
    const meta = this.index[key];
    if (!meta) return null;
    const fd = await fs.open(this.filename);
    const buf = Buffer.alloc(meta.len);
    await fd.read(buf, 0, meta.len, meta.pos);
    await fd.close();
    const keyLen = buf.readUInt32LE(0);
    const valLen = buf.readUInt32LE(4);
    const valStr = buf.subarray(8 + keyLen, 8 + keyLen + valLen).toString();
    const parsed = JSON.parse(valStr);
    return parsed.deleted ? null : parsed.v;
  }

  async del(key) {
    return this.mutex.run(async () => {
      const valStr = JSON.stringify({ v: null, deleted: true });
      const keyBuf = Buffer.from(key);
      const valBuf = Buffer.from(valStr);

      const header = Buffer.alloc(8);
      header.writeUInt32LE(keyBuf.length, 0);
      header.writeUInt32LE(valBuf.length, 4);

      const record = Buffer.concat([header, keyBuf, valBuf]);

      await fs.appendFile(this.walFile, record);
      await fs.appendFile(this.filename, record);
      await fs.truncate(this.walFile, 0);

      const pos = (await fs.stat(this.filename)).size - record.length;
      this.index[key] = { pos, len: record.length };
    });
  }
}



